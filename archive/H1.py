import numpy as np


"""Linear Triangle Basis (H1)"""


def eval_shape_funcs(xi, eta):
    N = np.array(
        [
            1.0 - xi - eta,
            xi,
            eta,
        ]
    )
    Nxi = np.array([-1.0, 1.0, 0.0])
    Neta = np.array([-1.0, 0.0, 1.0])

    return N, Nxi, Neta


def dot(N, u):
    return N[0] * u[0] + N[1] * u[1] + N[2] * u[2]


def compute_detJ(xi, eta, X, Y):
    N, N_xi, N_ea = eval_shape_funcs(xi, eta)

    x_xi = dot(N_xi, X)
    x_ea = dot(N_ea, X)

    y_xi = dot(N_xi, Y)
    y_ea = dot(N_ea, Y)

    detJ = x_xi * y_ea - x_ea * y_xi
    return x_xi, x_ea, y_xi, y_ea, detJ


def compute_shape_derivs(xi, eta, X, Y):
    N, N_xi, N_ea = eval_shape_funcs(xi, eta)

    x_xi, x_ea, y_xi, y_ea, detJ = compute_detJ(xi, eta, X, Y)

    invJ = [[y_ea / detJ, -x_ea / detJ], [-y_xi / detJ, x_xi / detJ]]

    Nx = [
        invJ[0][0] * N_xi[0] + invJ[1][0] * N_ea[0],
        invJ[0][0] * N_xi[1] + invJ[1][0] * N_ea[1],
        invJ[0][0] * N_xi[2] + invJ[1][0] * N_ea[2],
    ]

    Ny = [
        invJ[0][1] * N_xi[0] + invJ[1][1] * N_ea[0],
        invJ[0][1] * N_xi[1] + invJ[1][1] * N_ea[1],
        invJ[0][1] * N_xi[2] + invJ[1][1] * N_ea[2],
    ]

    return N, N_xi, N_ea, Nx, Ny, invJ


def transform(xi, eta, n1_coords, n2_coords, n3_coords):
    """
    x = x coordinates for element
    y = y coordinates for element
    """
    N, _, _ = eval_shape_funcs(xi, eta)
    x = [n1_coords[0], n2_coords[0], n3_coords[0]]
    y = [n1_coords[1], n2_coords[1], n3_coords[1]]
    return np.dot(N, x), np.dot(N, y)
